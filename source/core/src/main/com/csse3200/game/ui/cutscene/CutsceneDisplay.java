package com.csse3200.game.ui.cutscene;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.csse3200.game.areas.GameArea;
import com.csse3200.game.files.UserSettings;
import com.csse3200.game.services.ServiceLocator;
import com.csse3200.game.ui.UIComponent;
import com.csse3200.game.ui.cutscene.CutsceneReaderComponent.TextBox;
import com.github.tommyettinger.textra.TypingLabel;

import java.util.List;

/**
 * Component that can be attached to an entity in order to render necessary visual elements for
 * a cutscene (text boxes, buttons, background). Also handles button presses for progressing
 * cutscene
 */
public class CutsceneDisplay extends UIComponent {
    private Sound buttonClickSound;
    /**
     * Ordered list of text boxes to be displayed in cutscene
     */
    private final List<TextBox> textBoxList;
    /**
     * Reference to the game area the entity this component is attached to is inside of
     */
    private final GameArea area;
    /**
     * A reference to what text box is currently being displayed
     */
    private int curTextBox = 0;
    /**
     * Root table to be rendered
     */
    private Stack rootStack;
    /**
     * Text table inside of root table
     */
    private Table textTable;
    /**
     * Table to hold background image inside of root table
     */
    private Table imageTable;
    /**
     * Texture for background behind the text
     */
    private Texture textBgTexture;
    /**
     * For the hint in the top screen of cutscenes
     */
    private Table skipHintTable;
    /**
     * Initialises the UI for the cutscene
     *
     * @param textBoxList An ordered list of all text boxes to show, generated by a
     *                    CutsceneReaderComponent ideally
     * @param area        The instance of the GameArea the entity this component is attached to
     *                    is apart of
     */
    public CutsceneDisplay(List<TextBox> textBoxList, GameArea area) {
        this.textBoxList = textBoxList;
        this.area = area;
    }

    /**
     * Generates a stack which is rendered to the UI. The stack has two layers:
     * <p>
     * - A background
     * <p>
     * - A text box (containing text and button)
     * <p>
     * Also attaches an event listener to the button in the text box to progress to next text boss,
     * and load next GameArea when necessary
     */
    @Override
    public void create() {
        super.create();

        buttonClickSound = ServiceLocator.getResourceService()
                .getAsset("sounds/buttonsound.mp3", Sound.class);

        // Create root stack - fills screen
        rootStack = new Stack();
        rootStack.setFillParent(true);

        // Create background layer
        imageTable = new Table();
        rootStack.add(imageTable);

        // Create UI table
        Table uiTable = new Table();
        uiTable.bottom();
        rootStack.add(uiTable);

        // Create text box container
        Table textBoxContainer = new Table();

        // Create transparent background for text box
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(0, 0, 0, 0.5f);
        pixmap.fill();
        textBgTexture = new Texture(pixmap);
        pixmap.dispose();
        textBoxContainer.setBackground(new Image(textBgTexture).getDrawable());

        // Add text table to text container
        textTable = new Table();
        textBoxContainer.add(textTable).expandX().fillX().pad(20f);

        // Add button to text container
        TextButton progressButton = new TextButton("Next", skin, "cutsceneNext");
        textBoxContainer.add(progressButton).pad(20f);


        // Add text box container to UI table
        uiTable.add(textBoxContainer).expandX().fillX().pad(20f);

        // Create listener for progress button
        progressButton.addListener(
                new ChangeListener() {
                    @Override
                    public void changed(ChangeEvent event, Actor actor) {
                        buttonClickSound.play(UserSettings.get().masterVolume);
                        // Do nothing for now if we are on last index
                        if (curTextBox == textBoxList.size() - 1) {
                            area.trigger("cutsceneFinished");
                            entity.dispose();
                        } else {
                            nextTextBox();
                        }
                    }
                }
        );

        // Draw the first text box
        setTextBox();

        // Add stack to scene
        stage.addActor(rootStack);
        // Create skip hint label
        Label skipHint = new Label("(Press SPACE to skip)", skin, "small");
        skipHint.setFontScale(0.7f);

        // Create a table just for positioning
        skipHintTable = new Table();
        skipHintTable.top().right();   // align top-right
        skipHintTable.setFillParent(true);
        skipHintTable.add(skipHint).pad(10f).right().top();

        // Add to stage separately
        stage.addActor(skipHintTable);

    }

    /**
     * Updates the UI with information from the current text box. It sets the text to be typed out
     * in the text box, and a new background for the cutscene, if found.
     */
    private void setTextBox() {
        // Clear text table
        if (textTable != null) {
            textTable.clear();
        }
        // Get text box from list
        TextBox textBox = textBoxList.get(curTextBox);

        // Generate label
        TypingLabel text = new TypingLabel(textBox.text(), skin);
        text.setWrap(true);

        // Add label to text table
        textTable.add(text).expandX().fillX().pad(15f);

        // If background associated with new text box is null, don't change
        if (textBox.background() != null) {
            // Fade out old background if it exists
            if (imageTable.getChildren().size > 0) {
                Actor oldBg = imageTable.getChildren().first();
                oldBg.addAction(Actions.sequence(
                        Actions.fadeOut(0.5f),          // fade out over 0.5s
                        Actions.run(oldBg::remove)      // remove after fade
                ));
            }

            // Add new background, start invisible
            Image newBg = new Image(ServiceLocator.getResourceService()
                    .getAsset(textBox.background(), Texture.class));
            newBg.setFillParent(true);
            newBg.getColor().a = 0f; // start transparent
            imageTable.addActor(newBg);

            // Fade in new background
            newBg.addAction(Actions.fadeIn(0.5f));
        }
    }

    /**
     * Method that updates the current text box points to the next text box
     */
    private void nextTextBox() {
        curTextBox++;
        setTextBox();
    }

    /**
     * Draw is not used by an instance of this component as the Stack is handled by Scene2D
     * @param batch Batch to render to.
     */
    @Override
    protected void draw(SpriteBatch batch) {
        // Handled by Scene2D
    }
    @Override
    public void update() {
        super.update();

        if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
            if (curTextBox == textBoxList.size() - 1) {
                // Last one → finish cutscene
                area.trigger("cutsceneFinished");
            } else {
                // Otherwise → go to next text box
                nextTextBox();
            }
        }
    }

    /**
     * Correctly removes all widgets registered in the root stack object
     */
    @Override
    public void dispose() {
        super.dispose();

        if (rootStack != null) {
            rootStack.remove();
        }
        if (skipHintTable != null) {
            skipHintTable.remove();
        }
        if (textBgTexture != null) {
            textBgTexture.dispose();
        }
    }
}
